# 第五章 流水线处理器

## 流水线概述

### 单周期处理器的性能问题

- 处理器中的关键路径决定了时钟周期：单周期设计中，时钟周期数对于每条指令必须相等
  - 例如 load 指令，经历了完整的五个步骤：指令存储器、寄存器堆、ALU、数据存储器、寄存器堆
- **违反了设计思想**
  - **无法加速经常性事件：不能使用那些缩短常用指令执行时间而不改变最坏情况的实现技术**
- 可通过流水线来提高性能

### 流水线的概念介绍：一个比喻

以洗衣服为例类比流水线：重叠执行

假设洗衣包括四个步骤：洗衣机中洗衣、烘干机中烘干、叠衣服、收纳到柜子中，每个步骤 0.5 小时

![以洗衣服为例类比流水线](_images/%E4%BB%A5%E6%B4%97%E8%A1%A3%E6%9C%8D%E4%B8%BA%E4%BE%8B%E7%B1%BB%E6%AF%94%E6%B5%81%E6%B0%B4%E7%BA%BF.png)

非流水线：8 小时；

流水线：3.5 小时；

负载即任务数：

- 负载为 4，加速比 = 8 / 3.5 = 2.3；

- 负载足够多，加速比 = 2n / (0.5n + 1.5) ≈ 4 = **流水线中步骤的数目（流水线的级数）**。

### 流水线性能

- RISC-V 指令执行的五个阶段
  - IF (instruction fetch)：从存储器中取出指令
  - ID (instruction decode)：读寄存器并译码指令
  - EX (execute)：执行操作或计算地址
  - MEM (memory access)：访问数据存储器中的操作数（如有必要）
  - WB (write back)：将结果写入寄存器（如有必要）
- 让五个阶段重叠执行
- 假设各个阶段的耗时：
  - 寄存器堆的读或写为 100ps
  - 其他阶段为 200ps
- 比较流水线指令执行与单周期指令执行的平均执行时间

### 流水线加速比

- 如果流水线各阶段操作平衡
  - 例如：所有阶段需要相同的时间，则：指令执行时间（流水线） ≈ 指令执行时间（非流水线）/流水线级数
- 在理想条件和有大量指令的情况下，流水线带来的加速比约等于流水线的级数
- 若各阶段不完全平衡，加速比会变小
- 通过提高指令吞吐率来提高性能
  - **注意：单个指令的执行时间没有减少**

### 面向流水线的指令系统设计

- RISC-V 指令系统是面向流水线设计的
  - 所有 RISC-V 指令长度相同，都是 32 bits
  - 简化了流水线第一阶段取指令和第二阶段指令译码
  - x86: 1-17 bytes 的变长指令不利于流水线实现
- 只有 6 种指令格式，格式整齐，如源寄存器和目标寄存器位置相同
  - 能在一个阶段内完成译码和读寄存器
- 存储器操作只出现在 load / store 指令中
  - 可以利用执行阶段来计算存储器地址，然后在下一阶段访问存储器

### 流水线冒险

流水线中有一种情况，在下一个时钟周期中下一条指令无法执行，这种情况被称为**流水线冒险(hazard)**

- 结构冒险
  - 因**缺乏硬件支持**而导致指令不能在预定的时钟周期内执行的情况
- 数据冒险
  - 因**无法提供指令执行所需数据**而导致指令不能在预期的时钟周期内执行的情况。如**上下指令依赖**。
- 控制冒险（分支冒险）
  - 由于**取到的指令并不是所需要的**，或者**指令地址的流向不是流水线所预期**的，导致正确的指令无法在正确的时钟周期内执行的情况

#### 结构冒险

- 硬件资源不支持多条指令在同一时钟周期执行
- 假设下图 RISC-V 流水线结构只有一个存储器
  - <img src="_images/%E7%BB%93%E6%9E%84%E5%86%92%E9%99%A9.png" alt="结构冒险" style="zoom:75%;" />
  - load / store 需要访问存储器
  - 如果有第四条指令，则第一条指令从存储器取数据的同时，第四条指令从同一存储器取指令，流水线发生结构冒险
- 因此，流水线数据通路需要独立的指令 / 数据存储器，或者独立的指令 / 数据 cache

#### 数据冒险

一条指令依赖于前面一条尚在流水线中的指令运行结果。

```asm
add x19, x0 , x1
sub x2 , x19, x3
```

<img src="_images/%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9.png" alt="数据冒险" style="zoom:75%;" />

- 块中阴影在右边，意为进行读块中数据；块中阴影在左边，意为进行写块中数据；
- 整个是阴影，意为使用，没有阴影，意为不使用。
- bubble 是停顿，或者用两个空指令延迟。

##### 前递(forwarding)

一种解决数据冒险的方法

- 一旦 ALU 计算出结果，就提前取到数据，而不是等到数据到达寄存器或存储器
- 需要向内部资源添加额外的硬件
- <img src="_images/%E5%89%8D%E9%80%92.png" alt="前递" style="zoom:75%;" />

##### 载入-使用型数据冒险(load-use data hazard)

前递不能避免所有的流水线停顿

- 当载入指令要取的数据还没被取回，其他指令就需要该数据时，无法及时前递
- 一种解决方案：流水线停顿(stall)，也称为气泡(bubble)，为了解决冒险而实施的一种阻塞
- <img src="_images/%E8%BD%BD%E5%85%A5-%E4%BD%BF%E7%94%A8%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9.png" alt="载入-使用型数据冒险" style="zoom:75%;" />

##### 重排代码以避免流水线停顿

- 重排代码，避免在 load 指令之后立即使用取到的数据
- C code: a = b + e; c = b + f;
- <img src="_images/%E9%87%8D%E6%8E%92%E4%BB%A3%E7%A0%81%E4%BB%A5%E9%81%BF%E5%85%8D%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%81%9C%E9%A1%BF.png" alt="重排代码以避免流水线停顿" style="zoom:75%;" />

时钟周期计算方法：7 条指令，流水线，时钟周期为 7 + 4 = 11 个；

左边的加入了两个 stall，故为 13 个时钟周期；右边的就只有 11 个。

#### 控制冒险

- 控制冒险也称为分支冒险。分支决定了控制流：由于取到的指令并不是所需要的，或者指令地址的流向不是流水线所预期 ，导致正确的指令无法在正确的时钟周期内执行的情况
  - 分支指令之后的 IF 阶段依赖于分支的结果
  - 流水线无法保证永远取到正确的指令
    - 此时，分支指令仍在 ID 阶段，无法决定下一条要运行的指令
- 解决方案之一：
  - 在 RISC-V 流水线中**尽可能早地完成寄存器比较、分支目标地址计算**
  - 添加硬件，使得以上能在 ID 阶段完成

##### 方案一：每遇到条件分支指令就停顿的流水线

- 在取下一条指令之前，等待分支结果
- beq 指令的 ID 阶段“通过其他硬件电路”得到分支结果
- <img src="_images/%E6%AF%8F%E9%81%87%E5%88%B0%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E6%8C%87%E4%BB%A4%E5%B0%B1%E5%81%9C%E9%A1%BF%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="每遇到条件分支指令就停顿的流水线" style="zoom:75%;" />

- 解释：至少要等到上一条指令的 ID 阶段（Reg）结束，那么需要停顿一个周期（这里的周期指的是 200 ps，而非完整的 800 ps，是一个阶段的周期数时间）

##### 方案二：分支预测

- 对较长流水线而言，通常无法在第二阶段解决分支指令问题
  - **每个条件分支都停顿带来的代价太大，不可接受**
- 采用**预测**来处理条件分支
  - **只有预测错误时，才引发停顿**
- 例如：总是预测分支指令不跳转
  - 在分支指令之后，立即取址，流水线全速前进
  - 分支指令发生跳转时，流水线才会停顿
  - <img src="_images/%E6%80%BB%E6%98%AF%E9%A2%84%E6%B5%8B%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E4%B8%8D%E5%8F%91%E7%94%9F%E8%B7%B3%E8%BD%AC.png" alt="总是预测条件分支不发生跳转" style="zoom:75%;" />
  - 解释：不管 beq 的条件是否满足，ld 指令都在下一个阶段周期开始；可是在 beq 指令判断需要跳转之后，就舍弃 ld 指令，变为停顿，转而在下下个阶段周期执行跳转后的 or 指令。

###### 两种更成熟的分支预测（科普）

- 静态分支预测
  - 根据典型的分支行为来决定是否跳转
  - 例如：**循环** + 条件指令产生的分支
    - 在计算机程序中，**循环底部是条件分支指令**，并会跳转回循环顶部（回忆汇编程序内容）
    - 很可能发生分支并向回跳转，所以可以预测发生分支并跳到靠前的地址处
- 动态分支预测
  - 根据每个分支指令的**行为**进行预测
    - 一种常用实现方式：**保存**每个条件分支是否发生分支的历史**纪录**
  - **假设未来的行为会延续这个趋势**
    - 当预测错误时，需要停顿、重新取指令，并更新历史记录

### 流水线总结

- 流水线通过提高吞吐率来提升性能
  - 并行执行多条指令
  - 每条指令拥有相同的延迟
    - 延迟：执行单条指令的时间
- 会受到冒险的影响
  - 结构、数据、控制
- 指令集的设计影响到流水线实现的复杂度：指令长度相同、指令格式整齐和存储操作只发生在 load / store 指令中（RISC-V）。

### 一点习题

下面的程序在流水线处理器中执行时，程序 [填空1] 无需前递和停顿，程序[填空2] 需要停顿、程序 [填空3] 可使用前递避免停顿。

程序 1

```asm
ld x10, 0(x5)
add x11, x10, x10
```

很典型的使用停顿的情况，需要停顿，**似乎只有 load 需要停顿**。

程序 2

```asm
add  x11, x10, x10
addi x12, x10, 5
addi x14, x11, 5
```

图解，可知第一条的 x11 和第三条 x11 可能会导致冒险，故需要前递。

| Program execution order | time |  >   |                       >                       |                          >                          |  >   |  >   |  >   |
| :---------------------: | :--: | :--: | :-------------------------------------------: | :-------------------------------------------------: | :--: | :--: | :--: |
|  `add  x11, x10, x10`   |  IF  |  ID  |                    **EX**                     |                         MEM                         |  WB  |      |      |
|   `addi x12, x10, 5`    |      |  IF  |                      ID                       |                         EX                          | MEM  |  WB  |      |
|   `addi x14, x11, 5`    |      |      |                      IF                       |                       **ID**                        |  EX  | MEM  |  WB  |
|                         |      |      | `add  x11, x10, x10` x11 在 EX 结束后计算完成 | `addi x14, x11, 5` 在 ID 结束后需要通过前递获得 x11 |      |      |      |

程序 3

```asm
addi x12, x10, 5
addi x14, x10, 5
addi x16, x10, 7
addi x13, x10, 9
addi x17, x10, 8
addi x15, x10, 15
```

看似长，但其实之间没有什么关联，故无需前递和停顿。

答：3 1 2

## 流水线数据通路和控制

### 构建 RISC-V 流水线数据通路

<img src="_images/%E6%9E%84%E5%BB%BARISC-V%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF.png" alt="构建RISC-V流水线数据通路" style="zoom:75%;" />

*该数据通路图和上一章所讲有区别，不需要深究，仅用于本章教学。*

洗衣过程不会逆向移动，但是在从左到右的指令流动过程中，存在两个特殊情况：

- **写回阶段**：将结果写回位于数据通路中的寄存器堆；（数据冒险）
- **下一条指令 PC 的选择**：在自增 PC 值与 MEM (数据存储器访问)阶段的分支地址之间进行选择。（控制冒险）

### 流水线通路如何执行？

<img src="_images/%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%80%9A%E8%B7%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C.png" alt="流水线通路如何执行" style="zoom:75%;" />

- 并不是每一条指令都有一条独立的数据通路，而是共享一个复杂的数据通路；

- 同一（小）周期内，一个模块只有一条指令（的执行）在使用；

- 这样一个（小）周期内，最多同时执行五条指令，因为模块只有五个。

- **注意：图中，`ld x10, 40(x1)` 和 `ld x13, 48(x1)` 有冒险，`ld x10, 40(x1)` 的 rd = x10，而 `ld x13, 48(x1)` 的 rd = x13，会有冲突。**

### 在流水线数据通路中观察指令的流动

#### 观察采用流水线寄存器的流水线操作

加入流水线寄存器——在流水线数据通路中，观察指令在不同周期的流动

<img src="_images/%E8%A7%82%E5%AF%9F%E9%87%87%E7%94%A8%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%93%8D%E4%BD%9C.png" alt="观察采用流水线寄存器的流水线操作" style="zoom:75%;" />

- 每隔一个小周期，到了时钟上升沿，就会把值写到流水线寄存器中。这样就可以解决值的问题：

  - 从 `ld x10, 40(x1)` 开始分析，CC2 上升沿时，1 号寄存器会存入 x10 的值；1 号寄存器的值会被 Reg 阶段读取，同时在 `sub x11, x2, x3` 指令的 IM 阶段结束后（CC3 上升沿）被修改；

  - 在 CC5 上升沿时，4 号寄存器存入 x10 的值，与此同时，1 号寄存器存入 x13 的值。

- 有了流水线寄存器这一中介，解决了结构冒险的问题。

#### 观察流水线操作

- 在流水线数据通路中，观察指令在不同周期的流动
  - 单时钟周期流水线图（一个时钟周期的**垂直切片**，局部）
    - 展现流水线在指定时钟周期上每条指令对数据通路的使用情况
    - **高亮表示使用到的硬件资源**
- 多时钟周期流水线图
  - 展现一段时间的情况（如上图）
- PS：详细讲解见下。

#### 加入流水线寄存器

- 流水线寄存器：保存前一个阶段产生的信息
  - 数据写入受时钟控制
- <img src="_images/%E5%8A%A0%E5%85%A5%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="加入流水线寄存器" style="zoom:75%;" />
- 流水线寄存器的命名：IF/ID、ID/EX、EX/MEM、MEM/WB；
- 流水线寄存器中的数据：有 PC，还有指令片段等等...
  - IF/ID：PC[63:0], inst[31:0]
  - ID/EX：PC[63:0], Reg[rs1], Reg[rs2]
  - EX/MEM：PC + imm, zero, result, Reg[rs2]
  - MEM/WB：Read data, result
- 小问题：各个流水线寄存器的 PC 是一样的吗？——不是
  - 回顾上面的讲解，流水线寄存器在每一个时钟周期上升沿的时候都被改变了，PC 的位置都存的是当前指令执行中的 PC 值。

#### 观察 load 和 store 指令的操作

##### load

IF、ID、EX、MEM 阶段：

<img src="_images/ld%E5%89%8D%E5%87%A0%E6%AD%A5.png" alt="ld前几步" style="zoom:150%;" />

WB 阶段及其更正：

<img src="_images/wb%E9%94%99%E8%AF%AF%E5%8F%8A%E6%9B%B4%E6%AD%A3.png" alt="wb错误及更正" style="zoom:22%;" />

**写回的寄存器编号不正确，流水线寄存器应该还要保存写回的寄存器的编号。**

##### store

store 的 EX、MEM、WB 阶段：

<img src="_images/sd%E7%9A%84ex-mem-wb%E9%98%B6%E6%AE%B5.png" alt="sd的ex-mem-wb阶段" style="zoom:22%;" />

#### 用于加载指令的全部五个流水线阶段部分

<img src="_images/%E7%94%A8%E4%BA%8E%E5%8A%A0%E8%BD%BD%E6%8C%87%E4%BB%A4%E7%9A%84%E5%85%A8%E9%83%A8%E4%BA%94%E4%B8%AA%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%98%B6%E6%AE%B5%E9%83%A8%E5%88%86.png" alt="用于加载指令的全部五个流水线阶段部分" style="zoom:75%;" />

- 若要将相关信息从之前的流水线阶段传递到后续的流水线阶段，须将他们放置在流水线寄存器中。
- 在流水线通路设计中的每一个逻辑部件，只能在单个流水线阶段中被使用，否则会发生结构冒险。

#### 多时钟周期流水线图

- 显示了每个流水线阶段中使用的物理资源
  - <img src="_images/%E5%A4%9A%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%9B%BE.png" alt="多时钟周期流水线图" style="zoom:75%;" />
- 用矩形块来命名每个流水线阶段
  - <img src="_images/%E7%94%A8%E7%9F%A9%E5%BD%A2%E5%9D%97%E6%9D%A5%E5%91%BD%E5%90%8D%E6%AF%8F%E4%B8%AA%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%98%B6%E6%AE%B5.png" alt="用矩形块来命名每个流水线阶段" style="zoom:75%;" />

#### 一个时钟周期下的流水线图

- 显示了给定周期中流水线的状态
  - 单时钟周期图是多时钟周期图里一个时钟周期的垂直切片
  - <img src="_images/%E4%B8%80%E4%B8%AA%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F%E4%B8%8B%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%9B%BE.png" alt="一个时钟周期下的流水线图" style="zoom:75%;" />
  - 计算机并不知道提取的是哪一种指令，因此，它必须为任何一种指令做好准备，将所有可能有用的信息沿流水线传递出去

#### 流水线控制

- 控制信号**从指令中产生**，与单周期实现相似
- 根据流水线阶段**将控制线也划分成五组**
  - IF 和 ID 阶段没有需要特别控制的操作，没有控制信号
- <img src="_images/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8E%A7%E5%88%B6.png" alt="流水线控制" style="zoom:75%;" />
  - MemtoReg：选择器的控制信号，选择 ALU 或数据存储器值写入到寄存器堆
  - Regwrite：需要写回的寄存器的编号
  - Branch：分支指令的控制信号
  - MemRead：访存（数据存储器）控制使能，读
  - MemWrite：访存（数据存储器）控制使能，写
  - ALUOp：ALU 的控制信号
  - ALUSrc：ALU 前的选择器控制信号，用于选择 Reg[rs2] 或立即数值
- 当然，控制信号存在流水线寄存器中；用过且不再使用的信号就不传递到下一个阶段。

##### 简单的流水线控制

<img src="_images/%E7%AE%80%E5%8D%95%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8E%A7%E5%88%B6.png" alt="简单的流水线控制" style="zoom:22%;" />

逐步完善数据通路...

## 数据冒险：前递与停顿

### ALU 相关指令中的数据冒险

- 考虑以下指令序列:

  ```asm
  sub x2 , x1, x3 # x2:10 (before); -20 (after)
  and x12, x2, x5
  or  x13, x6, x2
  add x14, x2, x2
  sd  x15, 100(x2)
  ```
  
  后面四条指令都依赖于第一条指令，可能会有冒险。
  
- 通过**前递**来解决这些冒险

  - 那么**如何发现何时该前递**？

### 依赖关系与前递

<img src="_images/%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%89%8D%E9%80%92.png" alt="依赖关系与前递" style="zoom:75%;" />

- ***在同一个时钟周期，寄存器堆的先写后读或者先读后写不影响输出的正确性；但图中画的先写后读方便理解。因此这里 `add x14, x2, x2` 不需要前递。***

- `sd x15, 100(x2)` 也不需要前递。
- `and x12, x2, x5` 和 `or x13, x6, x2` 需要前递。

### 检测前递发生

- 命名流水线寄存器字段

  - 例：ID/EX.RegisterRs1 代表 ID/EX 流水线寄存器中，存放寄存器字段的编号 Rs1

- EX 阶段中，ALU操作数寄存器字段名称分别是：

  - ID/EX.RegisterRs1, ID/EX.RegisterRs2

- 两组数据冒险：

  - EX 冒险

    - EX/MEM.RegisterRd = ID/EX.RegisterRs1

    - EX/MEM.RegisterRd = ID/EX.RegisterRs2

    - |                     |        |        |      |      |      |      |
      | :-----------------: | :----: | :----: | :--: | :--: | :--: | :--: |
      | sub **x2**, x1, x3  | 取指令 |  译码  | 执行 | 访存 | 写回 |      |
      | and x12, **x2**, x5 |        | 取指令 | 译码 | 执行 | 访存 | 写回 |

  - MEM 冒险

    - MEM/WB.RegisterRd = ID/EX.RegisterRs1

    - MEM/WB.RegisterRd = ID/EX.RegisterRs2

    - |                     |        |        |        |      |      |      |      |
      | :-----------------: | :----: | :----: | :----: | :--: | :--: | :--: | :--: |
      | sub **x2**, x1, x3  | 取指令 |  译码  |  执行  | 访存 | 写回 |      |      |
      | and x12, **x2**, x5 |        | 取指令 |  译码  | 执行 | 访存 | 写回 |      |
      | or x13, x6, **x2**  |        |        | 取指令 | 译码 | 执行 | 访存 | 写回 |

- **并不是所有指令都会写回寄存器**，在前递的时候还应：

  - 检查 RegWrite 信号是否有效

    - 问题：无法区分 rd 和 imm[4:0]

      - ```asm
        sd  x1, 8(x2)
        add 3, x8, x2
        ```

      - |      |           |      |      |       |          |        |
        | :--: | :-------: | :--: | :--: | :---: | :------: | :----: |
        | R 型 |   func7   | rs2  | rs1  | func3 |    rd    | opcode |
        | S 型 | imm[11:5] | rs2  | rs1  | func3 | imm[4:0] | opcode |

    - EX 冒险：EX/MEM.RegWrite ≠ 0

    - MEM 冒险：MEM/WB.RegWrite ≠ 0

- 冒险的检测条件仍然不完善

  - 问题：Rd = x0？等于 0 就不用前递了。

    - ```asm
      sub x0, x1, x3
      and x12,x0, x5
      ```

    - EX 冒险：EX/MEM. RegisterRd ≠ 0

    - MEM 冒险：MEM/WB. RegisterRd ≠ 0

  - 二次冒险：到底使用哪条指令的前递？只能前递上一条指令，如何用控制器实现...

    - ```asm
      add x1, x1, x2
      add x1, x1, x3
      add x1, x1, x4
      ```

### 依赖关系的变化

<img src="_images/%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E7%9A%84%E5%8F%98%E5%8C%96.png" alt="依赖关系的变化" style="zoom:75%;" />

依赖的某些变为了流水线寄存器。

### 添加前递所需硬件

*省略了 IF 阶段，因为 IF 阶段不需要前递。*

<img src="_images/%E6%B7%BB%E5%8A%A0%E5%89%8D%E9%80%92%E6%89%80%E9%9C%80%E7%A1%AC%E4%BB%B6.png" alt="添加前递所需硬件" style="zoom:22%;" />

- ```asm
  sub x2 , x1, x3
  and x12, x2, x5
  or  x13, x6, x2
  add x14, x2, x2
  sd  x15, 100(x2)
  ```

- 不仅接上了前递的数据线，还接上了前递的控制器。

- 加入前递之后，Rs1 和 Rs2 字段也要添加到 ID/EX 流水线寄存器中。

- 假设 `sub x2, x1, x3` 执行完 EX，`add x12, x2, x5` 执行完 ID，那么此时 EX/MEM 寄存器上对应位置就会有一条数据线通向 `add x12, x2, x5` 马上要通过的 ALU 模块前的数据线。

- 再假设 `sub x2, x1, x3` 执行完 MEM，`or x13, x6, x2` 执行完 ID，那么此时最右边选择器就有一条数据线通向 `or x13, x6, x2` 马上要通过的 ALU 模块前的数据线。

- 前递硬件中，多选器的控制值

  | ForwardB | Source |                         Explanation                          |
  | :------: | :----: | :----------------------------------------------------------: |
  |    00    | ID/EX  |                ALU 的第二个操作数来自寄存器堆                |
  |    10    | EX/MEM |        ALU 第二个操作数来自上一个 ALU 计算结果的前递         |
  |    01    | MEM/WB | ALU 的第二个操作数来自数据存储器或者更早的 ALU 计算结果的前递 |
  
  | ForwardA | Source |                         Explanation                          |
  | :------: | :----: | :----------------------------------------------------------: |
  |    00    | ID/EX  |                ALU 的第一个操作数来自寄存器堆                |
  |    10    | EX/MEM |        ALU 第一个操作数来自上一个 ALU 计算结果的前递         |
  |    01    | MEM/WB | ALU 的第一个操作数来自数据存储器或者更早的 ALU 计算结果的前递 |

### 检测 EX 冒险的条件、相应的前递控制

- `if (EX/MEM.RegWrite and (EX/MEM.RegisterRd ≠ 0) and (EX/MEM.RegisterRd = ID/EX.RegisterRs1)) ForwardA = 10`


- `if (EX/MEM.RegWrite and (EX/MEM.RegisterRd ≠ 0) and (EX/MEM.RegisterRd = ID/EX.RegisterRs2)) ForwardB = 10`

### MEM 冒险检测仍有问题：两次数据冒险

- 考虑以下指令序列：

  ```asm
  add x1,x1,x2
  add x1,x1,x3
  add x1,x1,x4
  ```
- <img src="_images/%E4%B8%A4%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9.png" alt="两次数据冒险"  />

- 两组数据冒险都发生

  - 对于第三条指令而言，应该使用最近的结果

- MEM 冒险前递的条件：只有 EX 冒险不发生的时候才前递

- 检测 MEM 冒险的条件、相应的前递控制

  - `if (MEM/WB.RegWrite and (MEM/WB.RegisterRd ≠ 0) and not (EX/MEM.RegWrite and (EX/MEM.RegisterRd ≠ 0) and (EX/MEM.RegisterRd = ID/EX.RegisterRs1)) and (MEM/WB.RegisterRd = ID/EX.RegisterRs1)) ForwardA = 01`

  - `if (MEM/WB.RegWrite and (MEM/WB.RegisterRd ≠ 0) and not(EX/MEM.RegWrite and (EX/MEM.RegisterRd ≠ 0) and (EX/MEM.RegisterRd = ID/EX.RegisterRs2)) and (MEM/WB.RegisterRd = ID/EX.RegisterRs2)) ForwardB = 01`


### 通过前递解决冒险的数据通路

<img src="_images/%E9%80%9A%E8%BF%87%E5%89%8D%E9%80%92%E8%A7%A3%E5%86%B3%E5%86%92%E9%99%A9%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF.png" alt="通过前递解决冒险的数据通路"  />

### 载入-使用(load-use)型数据冒险

<img src="_images/%E8%BD%BD%E5%85%A5-%E4%BD%BF%E7%94%A8(load-use)%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9.png" alt="载入-使用(load-use)型数据冒险"  />

如图，不可以**时空倒流**。

### 检测：载入-使用型数据冒险

- 在 load 指令的 EX 阶段和下一条指令的 ID 阶段进行检测

- ALU 操作数寄存器字段名称分别是：IF / ID.RegisterRs1, IF/ID.RegisterRs2

- 检测条件：`ID/EX.MemRead and ((ID/EX.RegisterRd = IF/ID.RegisterRs1) or (ID/EX.RegisterRd = IF/ID.RegisterRs2))`

- 如果检测到这种冒险，**停顿流水线（插入气泡）**，指令整体下移。

  <img src="_images/%E8%BD%BD%E5%85%A5-%E4%BD%BF%E7%94%A8%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9-%E6%8F%92%E5%85%A5%E6%B0%94%E6%B3%A1.png" alt="载入-使用型数据冒险-插入气泡"  />

### 如何停顿流水线?

被停顿的指令正处于 ID 阶段:

- **将 ID / EX 寄存器中控制信号全置为 0** (RegWrite, MemWrite...)

  - 被停顿的指令在 EX, MEM, WB 阶段执行空指令 nop
  - 在控制值均为 0 时，不会有寄存器或者存储器被写入数据

- **禁止 PC 寄存器和 IF / ID 寄存器内容发生改变**

  - ID 阶段的寄存器会继续使用 IF / ID 寄存器中相同字段读寄存器
  - 下一条指令会重新取指
  - 1 个时钟周期的停顿，能够让 ld 指令的 MEM 阶段完成
    - 就可以把取到的数据前递到 EX 阶段

- **Hazard detection unit**

  <img src="_images/%E5%81%9C%E9%A1%BF%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="停顿流水线"  />

### 停顿与性能

- 停顿会导致性能下降
  - 但为了得到正确的结果，需要停顿
- 编译器能**编排代码，尽量避免冒险和停顿**
  - 这需要流水线结构的知识

## 控制冒险

- **假设**分支结果在 MEM 阶段完成确认
  - 分支指令修改 PC 值发生在 MEM 阶段

<img src="_images/%E6%8E%A7%E5%88%B6%E5%86%92%E9%99%A9.png" alt="控制冒险"  />



### 假设分支不发生

- 默认不发生分支跳转
- 如果发生跳转，则清除掉后续的三条指令

<img src="_images/%E5%81%87%E8%AE%BE%E5%88%86%E6%94%AF%E4%B8%8D%E5%8F%91%E7%94%9F.png" alt="假设分支不发生"  />

### 缩短分支延迟

- 移动硬件，使得分支决定提前到 ID 阶段
  - 需要**提早计算分支目标地址**（IF/ID 寄存器中有 PC 和 Immediate）
  - 需要**提早判断分支条件**
- 例：分支跳转发生

  ```asm
  36: sub x10, x4, x8
  40: beq x1, x3, 16 # PC-relative branch to 40 + 16*2 = 72
  44: and x12, x2, x5
  48: or x13, x2, x6
  52: add x14, x4, x2
  56: sub x15, x6, x7
  ...
  72: ld x4, 50(x7)
  ```

- 寄存器堆后放置**比较器**

  <img src="_images/%E7%BC%A9%E7%9F%AD%E5%88%86%E6%94%AF%E5%BB%B6%E8%BF%9F.png" alt="缩短分支延迟"  />

  只清空了一条指令 `and x12, x2, x5`。

### 动态分支预测

- 对于更深的流水线，从时钟周期数的角度来说，分支预测错误的代价会增大。
- 使用动态分支预测
  - 一种实现方式：采用**分支预测缓存**或**分支历史表**
  - 是一块按照分支指令的低位地址索引定位的小容量存储器
  - 包含一个或多个位（bit）以表明一个分支最近是否发生了跳转
- 1-Bit 预测机制：用 1 位表示最近是否发生了跳转
  - 查表：**使用**表中记录的结果作为预测结果
  - 开始取指令
  - 如果预测错误，则清掉错误指令，并更改分支预测缓存中的记录

### 1-Bit 预测机制的缺点

- 一个条件分支总是发生跳转，但一旦其不发生跳转时，会导致两次预测错误，而不是只造成一次错误
  - <img src="_images/1-Bit%E9%A2%84%E6%B5%8B%E6%9C%BA%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9.png" alt="1-Bit预测机制的缺点" style="zoom:80%;" />
  - 内层循环的最后一次迭代不发生跳转，预测发生跳转，预测**错误**，更改预测值为**不跳转**。
  - 下一次外层循环开始后，内层循环第一次迭代**发生跳转**，预测不发生跳转，预测**错误**，更改预测值为**跳转**
  

### 2-Bit 预测机制

- 对于左侧两个状态，只有在发生了连续两次错误时预测 结果才会被改变（跳转加 1，不跳转减 1）
- <img src="_images/2-Bit%E9%A2%84%E6%B5%8B%E6%9C%BA%E5%88%B6.png" alt="2-Bit预测机制"  />

- 在一个分支经常跳转或经常不跳转的情况下（大多数分支都是这样的），只会发生一次预测失效

### 分支目标计算

- 除了判断分支是否发生，还要计算分支目标地址
  - 发生跳转时需要**一个时钟周期**的代价来计算分支目标地址
- 使用分支目标缓存
  - 缓存分支目标 PC 值或目标指令
  - 根据当前分支指令的 PC 值来索引定位
    - 如果缓存中有目标 PC 值或指令，且分支预测跳转，就能读取缓存结果，立即使用

## 例外

### 例外(exception)和中断(interrupt)——仅供了解，非考试内容

- 例外和中断是控制逻辑需要实现的任务之一
  - 除分支指令外，另一种改变指令执行控制流的方式
- 不同的 ISA 对于例外和中断的定义不同
  - Intel x86 使用中断同时指代两者
  - 对于 RISC-V
    - **例外指意外的控制流变化**，而这些变化无须区分产生原因是来自于处理器内部还是外部
    - **中断仅指由处理器外部事件引发**的控制流变化
- 对例外进行时序优化是困难的

### RISC-V 中的例外和中断示例

|         事件类型         | 来源 | RISC-V 中的表示 |
| :----------------------: | :--: | :-------------: |
|         系统重启         | 外部 |      例外       |
|      I / O设备请求       | 外部 |      中断       |
| 用户程序进行操作系统调用 | 内部 |      例外       |
|        未定义指令        | 内部 |      例外       |
|         硬件故障         | 皆可 |      皆可       |

### RISC-V 体系结构中如何处理例外

- 若执行某指令时出现硬件故障：保存发生例外的指令地址，将控制权转交给操作系统
  - 使用**系统例外程序计数器**(Supervisor Exception Program Counter, SEPC)保存发生例外的指令地址，64 位寄存器
  - 跳转到统一的入口地址，进行例外处理
    - $0000\_0000\_1C09\_0000_{hex}$
- 保存例外发生的原因
  - **系统例外原因寄存器**(Supervisor Exception Cause Register, SCAUSE)
  - SCAUSE：64 位寄存器，大多数位未被使用。

### 另一种例外处理方式(x86 等)

- 向量式中断（x86 中统称为中断）：采用基址寄存器加上例外原因（作为偏移）作为目标地址来完成控制流转换。
  - 基址寄存器中保存了向量式中断内存区域的起始地址
  - 例外原因决定后续控制流的起始地址
- 典型例外的偏移量：
  - 未定义指令的偏移量：$00\_0100\_0000_2$
  - 硬件故障的偏移量：$01\_1000\_0000_2$
- 操作系统可根据例外向量起始地址来确定例外原因

### 例外处理程序的工作

- 如果可以重启程序的执行（I/O 设备请求等）
  - 完成例外处理的所有操作
  - 使用 SEPC 寄存器中的内容重启程序的正常执行
- 否则（未定义指令或硬件故障等）
  - 停止当前程序的执行
  - 使用 SEPC、SCAUSE 等来报告错误

### 流水线实现中的例外

- 流水线实现中，将例外处理看作另一种控制冒险。

- 假设 4C: add 指令执行阶段发生了硬件故障：
  ```asm
  40 sub x11, x2, x4
  44 and x12, x2, x5
  48 or x13, x2, x6
  4C add x1, x2, x1
  50 sub x15, x6, x7
  54 ld x16, 100(x7)
  ...
  ```
  
- Handler
  ```asm
  1C090000 sd x26, 1000(x10)
  1C090004 sd x27, 1008(x10)
  ...
  ```

- 考虑 add 指令 `add x1, x2, x1` 的 EX 阶段发生了硬件故障
  - IF 阶段的指令：变为 nop 操作
  - ID 阶段的指令：增加新的逻辑部件，使得译码阶段的输出为 0
  - EX 阶段的指令：需要保留x1原本的值
  - add 之前的指令，正常完成
  - 设置 SEPC 和 SCAUSE 的寄存器值
  - 转到例外处理程序

*电路图见 PPT。*

### 流水线实现中的例外处理小结

- IF 阶段的指令：变为 nop 操作
- ID 阶段的指令：增加新的逻辑部件，使译码阶段输出为 0
- EX 阶段的指令：需要保留 x1原本的值
- 例外之前的指令，正常完成
- 设置 SEPC 和 SCAUSE 的寄存器值
- 转到例外处理程序