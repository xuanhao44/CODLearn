# 第三章 计算机的运算方法

*具体例子见 PPT 和作业三。*

## 定点运算

### 加减法运算——补码加减运算公式

#### 加法

- 整数：$[A]_{补} + [B]_{补} = [A + B]_{补} (\mod 2^{n+1})$

- 小数：$[A]_{补} + [B]_{补} = [A + B]_{补} (\mod 2)$

#### 减法

- 整数：$[A - B]_{补} = [A + (-B)]_{补} (\mod 2^{n+1})$

- 小数：$[A - B]_{补} = [A + (-B)]_{补} (\mod 2)$

连同符号位一起相加，符号位产生的进位自然丢掉。

#### 已知 $[X]_{补}$，求 $[-X]_{补}$

无论是小数还是整数，推导过程都是：

1. 根据符号位为 0 或 1 分开讨论
2. $[X]_{补}$ —> $[X]_{原}$ —> $[X]$ —> $[-X]$ —> $[-X]_{补}$

$[X]_{补}$ 连同符号位在内，每位取反，末位加 1，即得 $[-X]_{补}$

具体推导过程见 PPT，下面是另一种思考方式：

1. $[X]$ 是正数，$[X]$ 的补码和真值没区别，所以 $[-X]$ 补 就相当于先变成 $[-X]$（符号位取反），然后再数值位取反末尾加 1，也就是连同符号位在内，每位取反末位加 1。
2. $[X]$ 是负数，那么要求 $[-X]$ 这个正数的补码就等同于求 $[-X]$ 真值，我们知道从补码到原码的过程也是数值位取反末尾加 1，所以步骤也是符号位取反，然后数值位取反末尾加 1，也就是连同符号位在内，每位取反末位加 1。

一个关系：$[-X]_{补} \equiv -[X]_{补}$。

#### 补码加减运算公式实际运用——用补码运算求 $A - B$

联系上面补码加减运算公式就立即有：
$$
[A - B]_{补} = [A + (-B)]_{补} = [A]_{补} + [-B]_{补}
$$
所以步骤为：

1. 写出 $[A]_{补}, [B]_{补}$
2. 写出 $[-B]_{补}$
3. 列竖式计算 $[A]_{补} + [-B]_{补}$
4. 计算结果为 $[A]_{补} + [-B]_{补} = [A - B]_{补}$
5. 最后记得由补码求 $A - B$

##### 一位符号位判溢出

处理方法：最高有效位的进位 $\oplus$ 符号位的进位 = 1，即溢出

##### 两位符号位判溢出

最高符号位代表其真正的符号。

- 结果的双符号位相同，未溢出；

- 结果的双符号位不同，溢出。

### 一位乘法运算

#### 改进后的笔算乘法

- 乘法运算可用加和移位实现。
  - eg：n = 4，加 4 次，移 4 次。
- 由乘数的末位决定被乘数是否与原部分积相加，然后 ->1 位形成新的部分积，同时乘数 ->1 位（末位移丢），空出高位存放部分积的低位。
- 被乘数只与部分积的高位相加。

#### 原码乘法

1. 乘积的符号位 $x_0 \oplus y_0$
2. 数值部分按绝对值相乘

- 特点
  - 绝对值运算
  - 用移位的次数判断乘法是否结束
  - 逻辑移位

#### 补码乘法

补码一位乘法运算规则（小数）：

- 被乘数**任意**，乘数为**正**（**类似**原码乘) $y_0 = 0, [x \times y]_{补} = [x]_{补} \times y$
  - 但加和移位按**补码**规则运算，积的符号**自然形成**
- 被乘数**任意**，乘数为**负**
  - 乘数 $[y]_{补}$，**去掉符号位**，操作同上 ，最后**加 $[-x]_{补}$，校正**

$$
小数：[x \times y]_{补} = [x]_{补} \times (0.y_1 \cdots y_n) + [-x]_{补} y_0
$$

补码一位乘法运算规则（整数）：略，详见 PPT。
$$
整数：[X \times Y]_{补} = [X]_{补} \times [0 Y_{n-1} \cdots Y_1 Y_0]_{补} + 2^n [-X]_{补}
$$

#### Booth 算法（被乘数、乘数符号任意）

设 $x_{补} = x_0.x_1 x_2 \cdots x_n, y_{补} = y_0.y_1 y_2 \cdots y_n$
$$
\begin{equation}
\begin{split}
[x \cdot y]_{补} &= [x]_{补} \times (0.y_1 \cdots y_n) + [-x]_{补} y_0 \\
&= [x]_{补} \times (0.y_1 \cdots y_n) - [x]_{补} y_0 ([-X]_{补} \, \equiv -[X]_{补}) \\
&= [x]_{补} \times (y_1 2^{-1} + y_2 2^{-2} + \cdots + y_n 2^{-n}) - [x]_{补} y_0 \\
&= [x]_{补} \times (-y_0 + y_1 2^{-1} + y_2 2^{-2} + \cdots + y_n 2^{-n}) \\
&= [x]_{补} \times [-y_0 + y_1 (2^0 - 2^{-1}) + y_2 (2^{-1} - 2^{-2}) + \cdots + y_n (2^{-(n-1)} - 2^{-n})] \, (2^{-n} = 2^{-(n-1) - 2^{-2}}) \\
&= [x]_{补} \times [(y_1 -y_0) + (y_2 - y_1) 2^{-1} + \cdots + (y_n - y_{n-1}) 2^{-(n-1)} + (0 - y_n) 2^{-n}] \, (附加位 y_{n+1} = 0) \\
&= [x]_{补} \times [y_0' + y_1' 2^{-1} + \cdots + y_{n-1}' 2^{-(n-1)} + y_n' 2^{-n}] \, (y_n' = y_{n+1} - y_n)
\end{split}
\end{equation}
$$

$$
[z_0]_{补} = 0 \\
[z_1]_{补} = 2^{-1} \{y_n' [x]_{补} + [z_0]_{补}\} \\
\cdots \\
[z_n]_{补} = 2^{-1} \{y_1' [x]_{补} + [z_{n-1}]_{补}\} \\
[x \cdot y]_{补} = [z_n]_{补} + y_0' [x]_{补}
$$

原理又是秦九韶算法。
$$
\begin{equation}
\begin{split}
[x \cdot y]_{补} &= [x]_{补} \times [y_0' + y_1' 2^{-1} + \cdots + y_{n-1}' 2^{-(n-1)} + y_n' 2^{-n}] \\
&= [x]_{补} \times [y_0' + y_1' 2^{-1} + \cdots + 2^{-(n-1)} (y_{n-1}' + y_n' 2^{-1})] \\
& = [x]_{补} \times [y_0' + y_1' 2^{-1} + \cdots + y_{n-2}' 2^{-(n-2)} + 2^{-(n-1)} (y_{n-1}' + y_n' 2^{-1})] \\
& = [x]_{补} \times [y_0' + y_1' 2^{-1} + \cdots + 2^{-(n-2)} (y_{n-2}' + (y_{n-1}' + y_n' 2^{-1}) 2^{-1})] \\
& = \cdots
\end{split}
\end{equation}
$$
很显然，$y_n' = 2^{-1} = (y_n' + 0) 2^{-1}$，所以设
$$
S_0 = 0 \\
S_1 = (y_n' + S_0) 2^{-1} \\
S_2 = (y_{n-1}' + S_1) 2^{-1} \\
\cdots \\
S_n = (y_1' + S_{n-1}) 2^{-1} \\
[x \cdot y]_{补} = [x]_{补} \times (y_0' + S_n)
$$
显然，每一步到底是否要乘以 $[x]_{补}$，由 $y_n'$ 决定：

| $y_i$ | $y_{i+1}$ | $y_i'= y_{i+1} - y_i$ |
| :---: | :-------: | :-------------------: |
|   0   |     0     |           0           |
|   0   |     1     |           1           |
|   1   |     0     |          -1           |
|   1   |     1     |           0           |

更具体地说，在算乘法时，到底是否要在竖式中加 $[x]_{补}$，由 $y_n'$ 决定：$y_n'$ 是 1 就加 $[x]_{补}$，是 0 就不加，是 -1 就加 $-[x]_{补} \equiv +[-x]_{补}$。

###### 实际运用

*所以在计算时有很多东西就是顺理成章的了，比如最后一步不移位。*

1. 被乘数使用双符号位，乘数是单符号位，但是后面有多一位附加位，初始为 0。
2. 下面的表非常实用，一般做题时先画表，后计算。

| $y_i$ | $y_{i+1}$ | $y_i'= y_{i+1} - y_i$ |      操作       |
| :---: | :-------: | :-------------------: | :-------------: |
|   0   |     0     |           0           |       —>1       |
|   0   |     1     |           1           | +$[x]_{补}$—>1  |
|   1   |     0     |          -1           | +$[-x]_{补}$—>1 |
|   1   |     1     |           0           |       —>1       |

3. 最后一位不移位是因为上面推导中最后一步没有乘以 $2^{-1}$ 了，所以不用右移。

## 乘法小结

- **整数乘法**与**小数乘法**完全相同

  - 可用**逗号**代替小数点

- 原码乘：符号位**单独处理**

  补码乘：符号位**自然形成**

- 原码乘去掉符号位运算，即为无符号数乘法

- 不同的乘法运算需有不同的硬件支持

乘法器硬件部分略。

### 除法运算

#### 机器除法

- 符号位异或形成
- $|x| – |y| ＞ 0$ 上商 1
- $|x| – |y| ＜ 0$ 上商 0
- 余数**左移一位**低位补“0”**减**除数（这样必定可以使得在起存其最末尾上商）
- 1 倍字长加法器
- 在寄存器**最末位上商**

#### 原码除法

以小数为例。
$$
[x]_{原} = x0. x1x2 \dots xn \\
[y]_{原} = y0. y1y2 \dots yn
$$
式中

$x* = 0. x_1 x_2 \dots x_n$ 为 x 的绝对值
$y* = 0. y_1 y_2 \dots y_n$ 为 y 的绝对值

数值部分为绝对值相除 x*
y*
被除数不等于 0
除数不能为 0
小数定点除法 x* ＜ y* 整数定点除法 x* ＞ y*

#### 恢复余数法

#### 不恢复余数法（加减交替法）

## 浮点运算
