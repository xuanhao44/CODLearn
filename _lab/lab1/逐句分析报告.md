# 实验一

## 汇编

### main:

- `  addi	sp,sp,-16`
  - 将堆栈指针寄存器 sp 与立即数(-16)相加，再存入堆栈指针寄存器 sp，即 sp = sp + (-16)

- `  sd	ra,8(sp)`
  - 将返回地址寄存器 ra 的值储存到堆栈指针寄存器 sp 作为基地址再偏移 8 bytes 的主存中，即 8(sp) = ra

- `  li	a4,0`
  - 伪指令转化为 `addi a4,zero,0`：给 a4 寄存器赋值为 0，即 a4 = 0

- `  li	a2,0`
  - 伪指令转化为 `addi a2,zero,0`：给 a2 寄存器赋值为 0，即 a2 = 0

- `  j	.L2`
  - 伪指令转化为` jal,x0,.L2`：跳转到 Label 为 .L2 的指令处，不保存下一条指令地址，不返回。

### .L3:

- `  addiw	a4,a4,1`
  - 将寄存器 a4 与立即数1（先拓展字节，但仍然为 1）相加，再存入寄存器 a4，即 a4 = a4 + 1

### .L2:

- `  li	a5,7`
  - 伪指令转化为 `addi a5,zero,7`：给 a5 寄存器赋值为 7，即 a5 = 7

- `  bgt	a4,a5,.L6`
  - 伪指令转化为 `blt a5,a4,.L6`：如果 a5 < a4，程序跳到 .L6 处继续执行。

- `  li	a5,7`
  - 伪指令转化为 `addi a5,zero,7`：给 a5 寄存器赋值为 7，即 a5 = 7

- `  sraw	a5,a5,a4`
  - 将 a5 算数右移 a4 位，即 a5 = a5 >> a4

- `  andi	a5,a5,1`
  - 把符号位扩展的立即数 1（还是 1）和寄存器 a5 的值进行按位与，结果写入寄存器 a5，即 a5 = a5 & 1

- `  beqz	a5,.L3`
  - 伪指令转化为 `beq a5,x0,.L3`：如果 寄存器 a5 的值为 0，则跳转到 .L3

- `  li	a5,7`
  - 伪指令转化为 `addi a5,zero,7`：给 a5 寄存器赋值为 7，即 a5 = 7

- `  sllw	a5,a5,a4`
  - 将 a5 逻辑左移 a4 位，即 a5 = a5 << a4

- `  addw	a2,a5,a2`
  - 将寄存器 a5 与寄存器 a2 相加，再存入寄存器 a2，即 a2 = a5 + a2

- `  j	.L3`
  - 伪指令转化为 `jal,x0,.L3`：跳转到 Label 为 .L3 的指令处，不保存下一条指令地址，不返回。

### .L6:

- `  lla	a1,.LC0`
  - 将 .LC0 的地址加载到 a1 中。
  - 伪指令转化为 —— 根据反汇编得
    - `auipc a1,0x0`：把符号位扩展的 20 位（左移 12 位）的立即数 0x0 加到 PC 上，结果写入 a1，a1 = PC + (0x0) << 12
    - `mv a1,a1`：伪指令转化为 addi a1,a1,0：把寄存器 a1 的值转移到寄存器 a1 里，即 a1 = a1。
  
- `  li	a0,1`
  - 伪指令转化为 `addi a0,zero,1`：给 a0 寄存器赋值为 1，即 a0 = 1

- `  call	__printf_chk@plt`
  - 把下一条指令的地址（PC + 8）写入 x[rd]，然后把 PC 设为 symbol。（不理解）
  - 伪指令转化为 —— 根据反汇编得
    - `auipc ra,0x0`
      - 把符号位扩展的 20 位（左移 12 位）的立即数 0x0 加到 PC 上，结果写入 ra。即 ra = PC + (0x0) << 12；
    - `jalr ra,0(ra)`：跳转到 ra，不保存下一条指令地址，不返回。

- `  li	a0,0`
  - 伪指令转化为 `addi a0,zero,0`：给 a0 寄存器赋值为 0，即 a0 = 0

- `  ld	ra,8(sp)`
  - 从堆栈指针寄存器 sp 作为基地址再偏移 8 bytes 的主存中取出值，读入到返回地址寄存器 ra 中，即 ra = 8(sp)

- `  addi	sp,sp,16`
  - 将堆栈指针寄存器 sp 与立即数(16)相加，再存入堆栈指针寄存器 sp，即 sp = sp + 16

- `  jr	ra`
  - 伪指令转化为 `jalr zero,0(ra)`：跳转到 ra，不保存下一条指令地址，不返回。

## 机器码

### 0000000000000000 \<main\>:

- `   0:	ff010113          	addi	sp,sp,-16`
  - ff010113：二进制为11111111000000010000000100010011
  - funct3:000，rs1:00010，rd:00010，imm:111111110000，opcode:0010011
  - addi指令：sp = sp + (-16)

- `   4:	00113423          	sd	ra,8(sp)`
  - 00113423：二进制为00000000000100010011010000100011
  - funct3:011，rs1:00010，rs2:00001，imm:000000001000，opcode:0100011
  - sd指令：8(sp) = ra

- `   8:	00000713          	li	a4,0`
  - 00000713：二进制为00000000000000000000011100010011
  - funct3:000，rs1:00000，rd:01110，imm:000000000000，opcode:0010011
  - li(addi)指令：a4 = 0

- `   c:	00000613          	li	a2,0`
  - 00000613：二进制为00000000000000000000011000010011
  - funct3:000，rs1:00000，rd:01100，imm:000000000000，opcode:0010011
  - li(addi)指令：a2 = 0

- `  10:	0080006f          	j	18 <.L2>`
  - 0080006f：二进制为00000000100000000000000001101111
  - rd:00000，imm:00000000000000000100，opcode:1101111
  - jal指令：goto .L2

### 0000000000000014 <.L3>:

- `  14:	0017071b          	addiw	a4,a4,1`
  - 0017071b：二进制为00000000000101110000011100011011
  - funct3:000，rs1:01110，rd:01110，imm:000000000001，opcode:0011011
  - addiw指令：a4 = a4 + 1

### 0000000000000018 <.L2>:

- `  18:	00700793          	li	a5,7`
  - 00700793：二进制为00000000011100000000011110010011
  - funct3:000，rs1:00000，rd:01111，imm:000000000111，opcode:0010011
  - li(addi)指令：a5 = 7

- `  1c:	02e7c263          	blt	a5,a4,40 <.L6>`
  - 02e7c263：二进制为00000010111001111100001001100011
  - funct3:100，rs1:01111，rs2:01110，imm:000000010010，opcode:1100011
  - blt指令：`blt a5,a4,.L6`

- `  20:	00700793          	li	a5,7`
  - 00700793：二进制为00000000011100000000011110010011
  - funct3:000，rs1:00000，rd:01111，imm:000000000111，opcode:0010011
  - li(addi)指令：a5 = 7

- `  24:	40e7d7bb          	sraw	a5,a5,a4`
  - 40e7d7bb：二进制为01000000111001111101011110111011
  - funct7:0100000，funct3:101，rs1:01111，rs2:01110，rd:01111，opcode:0111011
  - sraw指令：a5 = a5 >> a4

- `  28:	0017f793          	andi	a5,a5,1`
  - 0017f793：二进制为00000000000101111111011110010011
  - funct3:111，rs1:01111，rd:01111，imm:000000000001，opcode:0010011
  - andi指令：a5 = a5 & 1

- `  2c:	fe0784e3          	beqz	a5,14 <.L3>`
  - fe0784e3：二进制为11111110000001111000010011100011
  - funct3:000，rs1:01111，rs2:00000，imm:111111110100，opcode:1100011
  - beq指令：`beq a5,x0,.L3`

- `  30:	00700793          	li	a5,7`
  - 00700793：二进制为00000000011100000000011110010011
  - funct3:000，rs1:00000，rd:01111，imm:000000000111，opcode:0010011
  - li(addi)指令：a5 = 7

- `  34:	00e797bb          	sllw	a5,a5,a4`
  - 00e797bb：二进制为00000000111001111001011110111011
  - funct7:0000000，funct3:001，rs1:01111，rs2:01110，rd:01111，opcode:0111011
  - sllw指令：a5 = a5 << a4

- `  38:	00c7863b          	addw	a2,a5,a2`
  - 00c7863b：二进制为00000000110001111000011000111011
  - funct7:0000000，funct3:000，rs1:01111，rs2:01100，rd:01100，opcode:0111011
  - addw指令：a2 = a5 + a2

- `  3c:	fd9ff06f          	j	14 <.L3>`
  - fd9ff06f：二进制为11111101100111111111000001101111
  - rd:00000，imm:11111111111111101100，opcode:1101111
  - jal指令：goto .L3

### 0000000000000040 <.L6>:

- `  40:	00000597          	auipc	a1,0x0`
  - 00000597：二进制为00000000000000000000010110010111
  - rd:01011，imm:00000000000000000000，opcode:0010111
  - auipc指令：a1 = PC + (0x0) << 12

- `  44:	00058593          	mv	a1,a1`
  - 00058593：二进制为00000000000001011000010110010011
  - funct3:000，rs1:01011，rd:01011，imm:000000000000，opcode:0010011
  - mv(addi)指令：a1 = a1

- `  48:	00100513          	li	a0,1`
  - 00100513：二进制为00000000000100000000010100010011
  - funct3:000，rs1:00000，rd:01010，imm:000000000001，opcode:0010011
  - li(addi)指令：a0 = 1

- `  4c:	00000097          	auipc	ra,0x0`
  - 00000097：二进制为00000000000000000000000010010111
  - rd:00001，imm:00000000000000000000，opcode:0010111
  - auipc指令：ra = PC + (0x0) << 12

- `  50:	000080e7          	jalr	ra # 4c <.L6+0xc>`
  - 000080e7：二进制为00000000000000001000000011100111
  - funct3:000，rs1:00001，rd:00001，imm:000000000000，opcode:1100111
  - jalr指令：goto ra

- `  54:	00000513          	li	a0,0`
  - 00000513：二进制为00000000000000000000010100010011
  - funct3:000，rs1:00000，rd:01010，imm:000000000000，opcode:0010011
  - li(addi)指令：a0 = 0

- `  58:	00813083          	ld	ra,8(sp)`
  - 00813083：二进制为00000000100000010011000010000011
  - funct3:011，rs1:00010，rd:00001，imm:000000001000，opcode:0000011
  - ld指令：ra = 8(sp)

- `  5c:	01010113          	addi	sp,sp,16`
  - 01010113：二进制为00000001000000010000000100010011
  - funct3:000，rs1:00010，rd:00010，imm:000000010000，opcode:0010011
  - addi指令：sp = sp + 16

- `  60:	00008067          	ret`
  - 00008067：二进制为00000000000000001000000001100111
  - funct3:000，rs1:00001，rd:00000，imm:000000000000，opcode:1100111
  - jalr指令：goto ra
