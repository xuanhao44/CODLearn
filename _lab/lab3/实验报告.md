# 实验三实验报告

## Booth 乘法器算法流程图

![Booth乘法器算法流程图](/_images/Booth%E4%B9%98%E6%B3%95%E5%99%A8%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

## 调试报告

仿真截图及时序分析，要求分析最少 3 次乘法运算

### 第一个乘法运算

x = 0006, y = 0005

![3.1.1](/_images/3.1.1.png)

55 - 65ns，start 信号拉高一个周期（10ns）。

65ns 时初始化：

- busy 置 1，计数器 cnt 置 0；
- 符号位 sign 置 0，计算结果 z 置 0；
- x_t 储存双符号位补码形式的 x，为 00006，x_c 存储双符号位补码形式的 -x，为 1fffa；y_t 存储单符号位 y 加辅助位，为 0000a；

busy 置 1开始一个周期后，也就是 75ns 时，计数器 cnt 开始每隔一个周期就加 1，直到加到 16 为止，总共 16 次。

注意：第一次运算从 cnt = 0 && busy = 1 的时候就开始了，也就是从 65ns，start 信号拉高一个周期后开始，然后在 cnt = f 时结束，也是进行了 16 次运算。

cnt = 0，{y_t[1],y_t[0]} = 2‘b10，sign <= 1，z <= fffd0000；

cnt = 1，{y_t[2],y_t[1]} = 2‘b01，sign <= 0，z <= 00018000；

cnt = 2，{y_t[3],y_t[2]} = 2‘b10，sign <= 1，z <= fffdc000；

cnt = 3，{y_t[4],y_t[3]} = 2‘b01，sign <= 0，z <= 0001e000；

cnt = 4，{y_t[5],y_t[4]} = 2‘b10，sign <= 0，z <= 0000f000；

cnt = 5，{y_t[6],y_t[5]} = 2‘b00，sign <= 0，z <= 00007800；

cnt = 6，{y_t[7],y_t[6]} = 2‘b00，sign <= 0，z <= 00003c00；

cnt = 7，{y_t[8],y_t[7]} = 2‘b00，sign <= 0，z <= 00001e00；

cnt = 8，{y_t[9],y_t[8]} = 2‘b00，sign <= 0，z <= 00000f00；

cnt = 9，{y_t[a],y_t[9]} = 2‘b00，sign <= 0，z <= 00000780；

cnt = a，{y_t[b],y_t[a]} = 2‘b00，sign <= 0，z <= 000003c0；

cnt = b，{y_t[c],y_t[b]} = 2‘b00，sign <= 0，z <= 000001e0；

cnt = c，{y_t[d],y_t[c]} = 2‘b00，sign <= 0，z <= 000000f0；

cnt = d，{y_t[e],y_t[d]} = 2‘b00，sign <= 0，z <= 00000078；

cnt = e，{y_t[f],y_t[e]} = 2‘b00，sign <= 0，z <= 0000003c；

cnt = f，{y_t[10],y_t[f]} = 2‘b00，sign <= 0，z <= 0000001e；

cnt = 10，无变化。

当 cnt 加至 $10_{(16)}$ 时，不再自增，并且会引起 busy 在下一个周期被置 0；同时，计算结果 z 也完成了在 cnt = f 时待到这周期的变化，计算完成，之后不再计算。

那么结果就是 0000001e。

### 第二个乘法运算

x = fffa, y = 0005

![3.1.2](/_images/3.1.2.png)

285 - 295ns，start 信号拉高一个周期（10ns）。

295ns 时初始化：

- busy 置 1，计数器 cnt 置 0；
- 符号位 sign 置 0，计算结果 z 置 0；
- x_t 储存双符号位补码形式的 x，为 1fffa，x_c 存储双符号位补码形式的 -x，为 00006；y_t 存储单符号位 y 加辅助位，为 0000a；

busy 置 1开始一个周期后，也就是 305ns 时，计数器 cnt 开始每隔一个周期就加 1，直到加到 16 为止，总共 16 次。

注意：第一次运算从 cnt = 0 && busy = 1 的时候就开始了，也就是从 295ns，start 信号拉高一个周期后开始，然后在 cnt = f 时结束，也是进行了 16 次运算。

cnt = 0，{y_t[1],y_t[0]} = 2‘b10，sign <= 1，z <= 00030000；

cnt = 1，{y_t[2],y_t[1]} = 2‘b01，sign <= 0，z <= fffe8000；

cnt = 2，{y_t[3],y_t[2]} = 2‘b10，sign <= 1，z <= 00024000；

cnt = 3，{y_t[4],y_t[3]} = 2‘b01，sign <= 0，z <= fffe2000；

cnt = 4，{y_t[5],y_t[4]} = 2‘b10，sign <= 0，z <= ffff1000；

cnt = 5，{y_t[6],y_t[5]} = 2‘b00，sign <= 0，z <= ffff8800；

cnt = 6，{y_t[7],y_t[6]} = 2‘b00，sign <= 0，z <= ffffc400；

cnt = 7，{y_t[8],y_t[7]} = 2‘b00，sign <= 0，z <= ffffe200；

cnt = 8，{y_t[9],y_t[8]} = 2‘b00，sign <= 0，z <= fffff100；

cnt = 9，{y_t[a],y_t[9]} = 2‘b00，sign <= 0，z <= fffff880；

cnt = a，{y_t[b],y_t[a]} = 2‘b00，sign <= 0，z <= fffffc40；

cnt = b，{y_t[c],y_t[b]} = 2‘b00，sign <= 0，z <= fffffe20；

cnt = c，{y_t[d],y_t[c]} = 2‘b00，sign <= 0，z <= ffffff10；

cnt = d，{y_t[e],y_t[d]} = 2‘b00，sign <= 0，z <= ffffff88；

cnt = e，{y_t[f],y_t[e]} = 2‘b00，sign <= 0，z <=ffffffc4；

cnt = f，{y_t[10],y_t[f]} = 2‘b00，sign <= 0，z <= ffffffe2；

cnt = 10，无变化。

当 cnt 加至 $10_{(16)}$​ 时，不再自增，并且会引起 busy 在下一个周期被置 0；同时，计算结果 z 也完成了在 cnt = f 时待到这周期的变化，计算完成，之后不再计算。

那么结果就是 ffffffe2。

### 第三个乘法运算

x = 0000, y = ff21

![3.1.3](/_images/3.1.3.png)

515 - 525ns，start 信号拉高一个周期（10ns）。

525ns 时初始化：

- busy 置 1，计数器 cnt 置 0；
- 符号位 sign 置 0，计算结果 z 置 0；
- x_t 储存双符号位补码形式的 x，为 00000，x_c 存储双符号位补码形式的 -x，为 00000；y_t 存储单符号位 y 加辅助位，为 1fe42；

busy 置 1开始一个周期后，也就是 535ns 时，计数器 cnt 开始每隔一个周期就加 1，直到加到 16 为止，总共 16 次。

注意：第一次运算从 cnt = 0 && busy = 1 的时候就开始了，也就是从 525ns，start 信号拉高一个周期后开始，然后在 cnt = f 时结束，也是进行了 16 次运算。

cnt = 0，sign <= 0，z <= 00000000；

...

cnt = 10，无变化。

注意到不管是 x_t 还是 x_c 都等于 00000，故不管何种情况，z 和 sign 的值都不变，一直保持为 0。

当 cnt 加至 $10_{(16)}$​ 时，不再自增，并且会引起 busy 在下一个周期被置 0；同时，计算结果 z 也完成了在 cnt = f 时待到这周期的变化，计算完成，之后不再计算。

那么结果就是 00000000。
