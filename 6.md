# 第六章 存储器

## 6.0 小结

***本章内容奇多无比，但并非所有都是重点，大多数仅了解，少数需要认真学习。***

- 了解各类 ROM、SRAM、DRAM 的工作原理。
- **理解** DRAM 和 SRAM 的异同点、**熟悉** CPU 与存储器之间的连接。
- **熟悉**原始数据和汉明码之间的相互转换。
- 了解单体多字系统、高位交叉编址多体存储；**理解**低位交叉编址多体存储的性能提升
- 理解 Cache 命中率、Cache 的读写操作（写直达 vs 写回）、**熟悉** Cache-主存地址映射。
- 了解虚拟存储器、初步了解 RAID。

## 6.1 存储器概述

### 6.1.1 存储器分类

- 按存储介质分类

  - **半导体存储器 TTL 、MOS：易失**

  - 磁表面存储器 磁头、载磁体

  - 磁芯存储器 硬磁材料、环状元件

  - 光盘存储器 激光、磁光材料


- 按存取方式分类
  - 存取时间与物理地址无关（**随机访问**）
    - 随机存储器（RAM）：在程序的执行过程中**可读可写**
    - 只读存储器（ROM）：在程序的执行过程中**只读**
  - 存取时间与物理地址有关（串行访问）
    - 顺序存取存储器 磁带
    - 直接存取存储器 磁盘
- 按在计算机中的作用分类
  - 高速缓冲存储器（Cache）：CPU寄存器和主存储器之间
  - 主存储器
    - RAM
      - 动态 RAM
      - 静态 RAM
    - ROM
      - MROM（Mask ROM，掩膜编程的只读存储器，它只能写入一次数据）
      - PROM（可编程只读存储器，一般只能写入一次数据）
      - EPROM（可擦除可编程只读存储器，可以多次写入数据）
      - EEPROM（电可擦除可编程只读存储器，与 EPROM 运行原理类似，但 抹除数据的方式不同，可以多次写入数据）
  - 辅助存储器：磁盘、磁带、光盘
  - 闪存（Flash Memory）：U盘、固态硬盘（SSD）

### 6.1.2 存储器的层次结构（重点）

- 存储器三个主要特性的关系

  <img src="_images/%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%89%E4%B8%AA%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="存储器三个主要特性的关系" style="zoom:75%;" />

- 缓存—主存层次和主存—辅存层次

  <img src="_images/%E7%BC%93%E5%AD%98%E2%80%94%E4%B8%BB%E5%AD%98%E5%B1%82%E6%AC%A1%E5%92%8C%E4%B8%BB%E5%AD%98%E2%80%94%E8%BE%85%E5%AD%98%E5%B1%82%E6%AC%A1.png" alt="缓存—主存层次和主存—辅存层次" style="zoom:75%;" />

  - 加缓存是因为 CPU 直接访问主存不够快，所以其作用是增加速度；
  - 加辅存是因为主存的容量不够，需要"增加"其容量。

### 6.1.3 程序运行的局部性原理（重点）

- 在一小段时间内，最近被访问过的程序和数据很可能再次被访问
- 在空间上这些被访问的程序和数据往往集中在一小片存储区
- 在访问顺序上，指令顺序执行比转移执行的可能性大(大约 5:1)
- 合理地把程序和数据分配在不同存储介质中
  - 如：可以将最近被访问过的程序或数据放入高速缓存中，当 CPU 再次访问这些程序或数据时，访问速度就可以大大提高

## 6.2 主存储器

### 6.2.1 概述

#### 主存的基本组成

- MDR（Memory Data  Regisiter）：保存要被写入/读出地址单元的数据
- MAR（Memory  Address Regisiter）：访问数据的地址
- <img src="_images/%E4%B8%BB%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png" alt="主存的基本组成" style="zoom:75%;" />
  - 可以看到 MDR 的数据总线是双向的，这是自然的，因为要能读也能写；
  - 还有控制电路控制读写，MAR 的地址总线在写的时候提供地址。

#### 主存和 CPU 的联系

<img src="_images/%E4%B8%BB%E5%AD%98%E5%92%8CCPU%E7%9A%84%E8%81%94%E7%B3%BB.png" alt="主存和CPU的联系" style="zoom:75%;" />

这张图把 CPU 和 主存抽象简化了一下。

#### 主存中存储单元地址的分配（重点，难）

- 什么是按 xx（字节，字）寻址：存储器的容量是一定的，那么在给其中的存储体划分地址的时候就会按照一定的单位去分配地址
  - 你可以**按字节寻址**，那么你的单位既然是字节（8 bits），那么你的寻址范围就是 M / 8（单位都是 bit）；
  - 如果你按字（16 位）寻址，那么你的单位是字（16 bits），那么你的寻址范围就是 M / 16；
  - 如果你按字（32 位）寻址，那么你的单位是字（32 bits），那么你的寻址范围就是 M / 32；
- eg：有一个 16 MB 的存储器，请分别写出按字节寻址、按字（16 位）寻址、按字（32 位）寻址下的寻址范围。
  - 16MB：16 MB 指的是容量；M 指的是 $2^{20}$，B 指的是字节，那么容量就为 $16 \times 2^{20} \times 8 = 2^{27}$ 位；
  - 按字节寻址，寻址范围： $2^{27} \div 8 = 2^{24} = 16 M$
  - 按字（16 位）寻址，寻址范围： $2^{27} \div 16 = 2^{24} = 8 M$
  - 按字（32 位）寻址，寻址范围： $2^{27} \div 32 = 2^{24} = 4 M$
- 可见在寻址的单位越来越大时，寻址范围就越来越小了。

#### 主存的技术指标

1. 存储容量 主存 存放二进制代码的总位数
2. 存储速度
   - 存取时间 存储器的访问时间 读出时间 写入时间
   - 存取周期 读周期 写周期 连续两次独立的存储器操作
     - （读或写）所需的 最小间隔时间
     - 读周期 写周期
3. 存储器的带宽 位/秒

### 6.2.2 半导体存储芯片简介

#### 半导体存储芯片的基本结构（重点，难）

- <img src="_images/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-1.png" alt="半导体存储芯片的基本结构-1" style="zoom:75%;" />

  - 地址线，数据线，存储电路，以及读写控制线是我们在先前讲过的；
    - 读写控制线：（可能有两种）
      1. $\overline{WE}$（低电平写，高电平读）
      2. $\overline{OE}$（允许读），$\overline{WE}$（允许写）
  - 译码驱动，读写电路作了解，之后细讲；
  - 片选线的作用是：该芯片只是很小的一个单元，存储体是由很多很多这样的单元以复杂的形式组合起来的，片选线的作用就是外部连接时可以通过这根数据线决定该存储芯片是否被使用。
    - 片选线：$\overline{CS}, \overline{CE}$

- 芯片容量的推理

  | 地址线（单向） | 数据线（双向） |      芯片容量      |
  | :------------: | :------------: | :----------------: |
  |       10       |       4        | $1 K \times 4$ 位  |
  |       14       |       1        | $16 K \times 1$ 位 |
  |       13       |       8        | $8 K \times 8$ 位  |

  地址线决定了能从主存中找到多少“块”存储单元，数据线的宽度（或者多少条线）反映了一个数据单元的位数

- 存储芯片**片选线**的作用（图示）
  - <img src="_images/%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%89%87%E9%80%89%E7%BA%BF%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="存储芯片片选线的作用" style="zoom:75%;" />
    - 首先需要由 8 片 $16K \times 1$ 位的芯片构成 $16K \times 8$ 位的存储体；
    - 再由 4 组这样的 $16K \times 8$ 位的存储体构成 $64K \times 8$ 位的存储器；
    - 地址的排列是顺序的，如图，第一组 0~ 16K - 1 等；
    - 那么片选线的作用就是检查地址，效果如图，地址需要对应的上才算是片选有效（芯片被使用）。

#### 半导体存储芯片的译码驱动方式

*图略，详细见 PPT 和视频。*

1. 线选法：**主要思想是用一根字选择线（字线）， 同时选中一个存储单元中的 8 位数据**
   - 只适用于容量不大的存储芯片
2. 重合法：**主要思想是使用“行列”选择线来选定存储单元**。

### 6.2.3 随机存取存储器（RAM）

#### 静态 RAM（SRAM）

- 介绍基本电路
  - 介绍电路的读/写操作
- 静态 RAM 芯片举例——Intel 2114
  - 介绍读写过程
  - 介绍读写时序

#### 动态RAM（DRAM）

- 介绍基本电路
  - 动态 RAM 主要是靠电容存储电荷的原理 来寄存信息($C_g$)。如果电容 $C_g$ 中存储有足够多的电荷，则表示存储信息“1”， 如果电容中没有存储电荷则表示存储信息“0”。
  - 三管式 / 单管式
  - 介绍电路的读/写操作
- 动态 RAM 举例——三管动态RAM芯片 
  - 介绍读写过程
  - 介绍读/写时序
- 动态 RAM 刷新
  - 电容存储电荷的方式存储“0”和“1” 电容易漏电，长期得不到访问的存储单元的原信息会慢慢消失；
  - 刷新是一种再生过程：先将原存信息读出，再由刷新放大器形成原信息并重新写入。
    - 集中刷新
    - 分散刷新
    - 分散刷新与集中刷新相结合（异步刷新）

#### DRAM 和 SRAM 的比较（重点）

作业里也有：

|                          | 缓存：静态 RAM(SRAM) | 主存：动态 RAM(DRAM) |
| :----------------------: | :------------------: | :------------------: |
| 基本存储元件（存储原理） |        触发器        |         电容         |
|          集成度          |          低          |          高          |
|         芯片引脚         |          多          |          少          |
|           功耗           |          大          |          小          |
|           价格           |          高          |          低          |
|           速度           |          快          |          慢          |
|         有无刷新         |          无          |          有          |

### 6.2.4 只读存储器（ROM）

*略，详见 PPT。*

### 6.2.5 存储器与 CPU 的连接（重点，难）

#### 存储器容量的扩展

- 位扩展（增加存储字长）

  - 用 2 片 $1K \times 4$ 位存储芯片组成 $1K \times 8$ 位的存储器
    - 首先，地址线都是 10 根，但前者只有 4 根数据线，后者有 8 根数据线，解决方式见图：
    - <img src="_images/%E4%BD%8D%E6%89%A9%E5%B1%95.png" alt="位扩展" style="zoom:75%;" />
    - 地址线 $A_0$ 到 $A_9$ 共十根，两个芯片都接上；
    - 数据线分为两组，分别接在两个芯片上；
    - 读写控制线和片选线也都同时接在两个芯片上，因为如果只是位拓展的话，是同时读写两个芯片，以及同时使用或者不使用两个芯片的。

- 字扩展（增加存储字的数量）

  - 用 2 片 $1K \times 8$ 位存储芯片组成 $2K \times 8$ 位的存储器
    - 首先，数据线都是 8 根，但前者只有 10 根地址线，后者有 11 根地址线，且不能同时读/写两个芯片，解决方式见图：
    - <img src="_images/%E5%AD%97%E6%89%A9%E5%B1%95.png" alt="字扩展" style="zoom:75%;" />
    - 数据线共八根都接上两个芯片；读写控制线也是如此；
    - 地址线 $A_0$ 到 $A_9$ 共 10 根，都正常的接在两个芯片上；
    - 重点关注“无处安放”的地址线 $A_{10}$ 和两个芯片上仍待连接的片选线
      - 一个芯片的片选线 $\overline{CS_0}$ 连到 $A_{10}$ 上，另一个芯片的片选线 $\overline{CS_1}$ 连到 $A_{10}$ 取反后的线上，这样就可以实现不同时读/写了，只要设计好先后顺序就行。

- 字、位扩展

  - 用 8 片 $1K \times 4$ 位存储芯片组成 $4K \times 8$ 位的存储器

    - 数据线：前者 4 根，后者 8 根，那么需要把两个存储芯片归为一组；

    - 地址线：前者 10 根，后者 12 根；

    - 地址线 $A_{10}, A_{11}$ 需经过片选译码器产生四条数据线，连向四组存储体；

      - 输入00，输出 1000；入01，输出 0100；输入10，输出 0010；输入11，输出 0001

    - <img src="_images/%E5%AD%97-%E4%BD%8D%E6%89%A9%E5%B1%95.png" alt="字-位扩展" style="zoom:75%;" />

      

#### 存储器与 CPU 连接的要点

1. 地址线的连接
   - **CPU 的地址线数往往比一个存储芯片的地址线数要多。**通常总是将 CPU 地址线的低位与存储芯片的地址线相连，**CPU 地址线的高位一般用于生成片选信号**。
   - 如：8 片 $1K \times 4$ 位的芯片扩展成 $4K \times 8$ 位的存储器，CPU 地址线为12 位，而存储芯片的地址线仅有 10 位。
2. 数据线的连接
   - **CPU 的数据线数与存储芯片的数据线数也不一定相等。**需要对存储芯片进行位扩展，使其与 CPU 的数据线数相等。
   - 如：8 片 $1K \times 4$ 位的芯片扩展成 $4K \times 8$ 位的存储器，CPU 数据线为 8 位，而存储芯片的数据线仅有 4 位。
3. 片选线的连接
   - 片选线的连接是 CPU 与存储芯片正确工作的关键。哪一片存储芯片被选中主要取决于存储芯片的片选控制端 $\overline{CS}$ 能否接收到来自 CPU 的片选有效信号（低电平有效）。
   - 片选有效信号与 CPU 访存控制信号 $\overline{MREQ}$ 有关。只有当 CPU 要求访存时，才需要选择存储芯片。
   - 片选有效信号还与地址有关。
   - 在实际应用中，我们会使用访存控制信号 $\overline{MREQ}$ 和高位地址共同产生片选有效信号。
4. 读/写命令线的连接
   - CPU 的读/写命令线（$\overline{WE}$）一般可以直接与存储芯片的读/写控制端相连，一般为高电平读，低电平写。
5. 合理选择存储芯片
   - 合理选择存储芯片主要包括选择芯片类型（RAM 或者 ROM），以及芯片的数量。
   - 通常选用 ROM 存放系统程序、标准子程序和常数。
   - 选用 RAM 存放用户程序。
6. 其他：时序、负载等
   - CPU 时序和存储器的时序要能够相互配合，才能够正确读出或写入数据。
   - 负载考虑的是 CPU 最多可以带动多少片存储芯片。

#### PPT 上几个例题（要看，很难）

### 6.2.6 存储器的校验

#### 合法编码集合与检错、纠错能力

下面列举一系列合法编码集合，并附加其检错、纠错能力说明。

1. {000, 001, 010, 011, 100, 101, 110, 111}

   - 检 0 位错、纠 0 位错

   - 因为囊括了所有三位机器码的类型，所以检查不出任何错误，也就是即使错了也不知道错了，也更不用提纠错。

2. {000, 011, 101, 110}

   - 检 1 位错、纠 0 位错

   - 可以检查出 100 这样错误了一位的数据，但它可能来自于 000，101，110，光凭借这样的编码集合无法纠错。

3. {000, 111}

   - 检 1 位错、纠 1 位错

   - 可以检查出 100 这样错误了一位的数据，如果只错误一位，那么它必然来自于 000，故而可以纠正 1 位的错误。

   - 错误 110 分析同理。

4. {0000, 1111}

   - 检 2 位错、纠 1 位错

   - 可以检查出 1000 这样错误了一位的数据，如果只错误一位，那么它必然来自于 0000，故而可以纠正 1 位的错误；

   - 也可以检查出 1100 这样错误了两位的数据，但它可能来自于 0000，也可能来自于 1111，那么该编码集合便无法纠正 2 位错误。

5. {00000, 11111}

   - 可以检查出 11000 这样错误了两位的数据，如果错误了两位，它必然来自于 00000，那么该编码集合可以纠正 2 位的错误。

   - 错误 11100 分析同理。

编码的检测能力和纠错能力与什么有关？——任意两组合法编码之间二进制位的最小差异数。

#### 编码的最小距离

- 定义：任意两组合法代码之间**二进制位数**的**最少差异**

- **编码的纠错 、检错能力与编码的最小距离有关**
- 公式：$L - 1 = D + C (D \ge C)$
  - L：编码的最小距离
  - D：检测错误的位数
  - C：纠正错误的位数
- 举例：
  - 上面的例 5：L = 5，D = 2，C = 2；
  - 上面的例 3：L = 3，D = 1，C = 1。

#### 汉明码的组成

- 汉明码是一种具有**一位**纠错能力的编码。
  - 计算机大概率只错一位。

- 组成汉明码的三要素：
  - 汉明码采用**奇偶校验**
    - eg：原数据 0010 0011，使用偶校验，如果数据中 1 的位数为偶数则在前面加 0，否则加 1，那么这里加 1，即 1 0010 0011；
  - 汉明码采用**分组校验**
    - eg：原数据 0010 0011，使用分组偶校验，可以采取前四位、后四位为两组（非唯一分组方法），那么结果就是 1 0010 0 0011；
  - 汉明码的分组是一种**非划分方式**

#### 汉明码的分组是一种非划分方式

- |            | 校检位 | 校检位 |      | 校检位 |      |      |      |
  | :--------: | :----: | :----: | :--: | :----: | :--: | :--: | :--: |
  | 二进制编号 | **1**  | **2**  |  3   | **4**  |  5   |  6   |  7   |

  分成三组，每组有 1 位校检位，共包括 4 位数据位 {3, 5, 6, 7}；

- <img src="_images/%E6%B1%89%E6%98%8E%E7%A0%81%E5%88%86%E7%BB%84-%E9%9D%9E%E5%88%92%E5%88%86%E6%96%B9%E5%BC%8F.png" alt="汉明码分组-非划分方式" style="zoom:75%;" />

  $P_1 = \{1, 3, 5, 7\}, P_2 = \{2, 3, 6, 7\}, P_3 = \{4, 5, 6, 7\}$

- 假设做偶校验，结果为 0 为无错误，那么（*还是注意前提是汉明码只具有一位纠错能力*）

  - $P_3 = 0, P_2 = 0, P_1 = 0$：无差错
  - $P_3 = 0, P_2 = 0, P_1 = 1$：只有组 1 有错误，那么错误的必然是 1；
  - $P_3 = 1, P_2 = 0, P_1 = 1$：只有组 2 没有错误，组 1 和组 3 都有错误，那么错误的必然是 5；
  - $P_3 = 1, P_2 = 1, P_1 = 0$：只有组 1 没有错误，组 2 和组 3 都有错误，那么错误的必然是 6；
  - $P_3 = 1, P_2 = 1, P_1 = 1$：三个组都有错，那么错误的必然是 7。
  - ...

#### 汉明码的组成的其他问题

- 校验位应放哪里呢？
  - **1, 2, 4, 8, …  位置放校验码**，$2^i (i = 0, 1, 2, 3, \cdots)$
- 如何分组的呢？
  - 第一组：编号二进制数末位为 1：001，011，101，111；
  - 第二组：编号二进制数倒数第二位为 1：010，011，110，111；
  - 第三组：编号二进制数倒数第三位为 1：100，101，110，111。

- 汉明码的组成需增添几位检测位？
  - $2^k \ge n + k + 1$，n 为数据位数，k 为 检测位数，1 的含义是全对的情况。
- 检测位的取值？
  - 与该位所在的检测“小组”中承担的奇偶校验任务有关，**各组都需要完成奇偶校验**。
  - eg：假设组 1 中，包含编号 1，3，5，7，其中 3，5，7 都是数据，为 0，1，1，那么如果要进行偶校验的话就需要加 0。

#### 各检测位 $C_i$ 所承担的检测小组

- $C_1$ 检测 $g_1$ 小组包含位 1, 3, 5, 7, 9, 11,... (XXXX1)
- $C_2$ 检测 $g_2$ 小组包含位 2, 3, 6, 7, 10, 11,... (XXX1X)
- $C_4$ 检测 $g_3$ 小组包含位 4, 5, 6, 7, 12, 13,... (XX1XX)
- $C_8$ 检测 $g_4$ 小组包含位 8, 9, 10, 11, 12, 13, 14, 15, 24,... (X1XXX)



- $g_i$ 小组独占第 $2_{i－1}$ 位
- $g_i$ 和 $g_j$ 小组共同占第 $2_{i－1} + 2_{j－1}$ 位
- $g_i$、$g_j$ 和 $g_l$ 小组共同占第 $2_{i－1} + 2_{j－1} + 2_{l－1}$ 位

#### 汉明码的纠错过程

形成新的检测位 $P_i$，其位数与增添的检测位有关，

如增添 3 位 （$k = 3$），新的检测位为 $P_4 P_2 P_1$。

以 $k = 3$ 为例，$P_i$ 的取值为（心算也行）
$$
P_1 = 位_1 \oplus 位_3 \oplus 位_5 \oplus 位_7 \\
P_2 = 位_2 \oplus 位_3 \oplus 位_6 \oplus 位_7 \\
P_4 = 位_4 \oplus 位_5 \oplus 位_6 \oplus 位_7
$$

对于按 “偶校验” 配置的汉明码，不出错时 $P_1= 0$，$P_2 = 0$，$P_4 = 0$

校验位出错可不纠错。

#### PPT 上几个例题

### 6.2.7 提高访存速度的措施

- 采用高速器件
  - SDRAM (同步 DRAM)
    - 在系统时钟的控制下进行读出和写入，**CPU 无须等待**
  - RDRAM
    - 由 Rambus 公司开发的改进版 DRAM
    - 主要解决存储器带宽问题
  - 带 Cache 的 DRAM （CDRAM）
    - 在 DRAM 的芯片内集成了一个由 SRAM 组成的 Cache，有利于猝发式读取，即 CPU 发出一个地址就可以连续访问一整个数据块（一般为 32 字节）。
- 采用层次结构 Cache – 主存
- **调整主存结构**

#### 调整主存结构，提高访存速度

##### 单体多字系统

- 思想：增加存储器带宽，提升单体存储器工作速度。 
- 如：在一个存取周期内，从同一地址取出 4 条指令，然后再逐条送到 CPU 执行，即每隔 1/4 存取周期，主存向 CPU 送一条指令，带宽相比原来提升了 4 倍。
- <img src="_images/%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E7%B3%BB%E7%BB%9F.png" alt="单体多字系统" style="zoom:75%;" />

- 缺陷：对于存储体，每次必须要写入/读出 4W 位
  - 若一条指令为 1W，指令读出时可能只有其中一条指令是有用的，如第一条指令是跳转指令
  - 数据写入时，当只写入 W 位数据时，其他 3W 位数据会被篡改

##### 多体并行系统

- 多体并行系统：采用多体模块组成的存储器。每个模块有相同的容量和存取速度。 

- 并行工作：同时访问 N 个模块，同时启动，同时读出，完全并行工作。

- 优点：

  1. 让不同的请求源同时访问不同的体，可**实现并行工作**。
     如：一个体与 CPU 交换信息时，另一个体可同时与外部设备进行访存。

  2. 体内连续编址，利于存储器扩充

- 缺点：体内指令的连续存放和顺序执行， 会造成某个存储体特别繁忙，其余存储体特别空闲。

- 高位交叉 顺序编址——各个体并行工作

  - <img src="_images/%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89.png" alt="高位交叉" style="zoom:22%;" />

- 低位交叉——各个体轮流编址
  - <img src="_images/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89.png" alt="低位交叉" style="zoom:22%;" />
  - 特点：**在不改变存取周期的前提下，增加存储器的带宽**
    - <img src="_images/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%9A%84%E7%89%B9%E7%82%B9.png" alt="低位交叉的特点" style="zoom:75%;" />
    - 负脉冲为各体工作启动信号
    - 带宽增加：CPU 交叉访问各体，各体读/写过程重叠执行，一个存储周期，存储器实际向 CPU 提供了 4 个存储字
  - 流水线方式存取：设**四体**低位交叉存储器，存取周期为 T，总线传输周期为 $τ$，为实现流水线方式存取，应满足 $T ＝ 4τ$。
    - <img src="_images/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%96%B9%E5%BC%8F%E5%AD%98%E5%8F%96.png" alt="流水线方式存取" style="zoom:75%;" />
    - 连续读取 4 个字所需的时间为 $T + (4 －1)τ$
    - 连续读取 n 个字所需的时间为 $T + (n－1)τ$
    - 非低位交叉存储器连续读取 n 个字所需的时间为 nT
    - 加速比为 $nT/(T+(n-1) τ) = 4nτ/((n+3) τ) = 4$ (n 足够大时)

##### 存储器控制部件（存控）

- 主要功能：合理安排各个部件的访存顺序，并产生相应的读/写控制信号

- <img src="_images/%E5%AD%98%E5%82%A8%E5%99%A8%E6%8E%A7%E5%88%B6%E9%83%A8%E4%BB%B6.png" alt="存储器控制部件" style="zoom:75%;" />

- 排队器：同一时刻出现多个请求源访问同一存储时，由排队器确定请求源访存的优先顺序
- 存控标记触发器 $C_M$：接收排队器输出的信号，一旦排队器响应某个请求源的请求，$C_M$ 就会启动节拍发生器工作。
- 节拍发生器：产生固定节拍，使得控制线路能够按照一定的时序发出控制信号。
- 控制线路：接收排队器输出的信号和节拍器产生的节拍信号，向存储器输出各种控制信号，完成存储器读/写操作，并向请求源发出回答信号，表示已经响应了请求。

## 6.3 高速缓冲存储器（重点，难）

### 6.3.1 概述

#### 为什么用 Cache？ 

- 避免 CPU “空等” 现象。

- CPU 和主存（DRAM）的速度差异：CPU 快，主存慢，那么就要加入缓存来加速这个数据交互的过程。
- <img src="_images/CPU%E5%92%8C%E4%B8%BB%E5%AD%98%E7%9A%84%E9%80%9F%E5%BA%A6%E5%B7%AE%E5%BC%82.png" alt="CPU和主存的速度差异" style="zoom:75%;" />

#### Cache 的工作原理

1. 主存和缓存的编址
   - <img src="_images/%E4%B8%BB%E5%AD%98%E5%92%8C%E7%BC%93%E5%AD%98%E7%9A%84%E7%BC%96%E5%9D%80.png" alt="主存和缓存的编址" style="zoom:75%;" />
   - Cache 的标记表示当前位置存放的是哪一个主存块。标记中存储的内容一般为主存字块的 m 位地址。
2. 命中与未命中
   - 缓存共有 C 块；主存共有 M 块；$M >> C$
   - 命中：主存块**调入**缓存，主存块与缓存块建立了对应关系；用**标记**记录与某缓存块建立了对应关系的**主存块号**
   - 未命中：主存块**未调入**缓存，主存块与缓存块未建立了对应关系。
3. Cache 的命中率
   - 定义：CPU 欲访问的信息在 Cache 中的 比率
   - 命中率与 Cache 的**容量与块长**有关
     - 块长：一个存取周期内从主存获取的信息长度
4. Cache – 主存系统的效率
   - 效率 e 与命中率有关，$e = \frac {访问 Cache 的时间} {平均访问时间} \times 100 \%$
   - 设 Cache 命中率 为 h，访问 Cache 的时间为 $t_c$， 访问主存的时间为 $t_m$，则 $e = \frac {t_c} {h \times t_c + (1 - h) \times t_m} \times 100 \%$（假设访问 Cache 和访问主存是同时进行的）
     - 很好理解的公式：命中了就是访问 Cache，即 $h \times t_c$；没命中就是访问主存，即 $(1 - h) \times t_c$；
     - eg：命中率 100%，那么 $e = 100 \%$，显然命中率越高，访问主存的时间就少，平均访问时间就越接近访问 Cache 的时间，效率就越高。

#### Cache 的基本结构

<img src="_images/Cache%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="Cache的基本结构" style="zoom:80%;" />

#### Cache 的读写操作

读：

<img src="_images/Cache%E8%AF%BB%E6%93%8D%E4%BD%9C.png" alt="Cache读操作" style="zoom:75%;" />

写：

- 写直达法（Write – through）
  - 写操作时数据既写入 Cache 又写入主存
  - 写操作时间就是**访问主存**的时间，读操作时不涉及对主存的写操作，更新策略比较容易实现
- 写回法（Write – back）
  - 写操作时只把数据写入 Cache 而不写入主存，当 Cache 数据被替换出去时才写回主存
  - 写操作时间就是**访问 Cache** 的时间，读操作 Cache 失效发生数据替换时，被替换的块需写回主存，增加了 Cache 的复杂性

### 6.3.2 Cache - 主存的地址映射

#### 直接映射

- 某一主存块只能固定映射到某一缓存块。
- <img src="_images/%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84.png" alt="直接映射" style="zoom:75%;" />
- 优点：直接映射实现/使用简单。
- 缺点：不够灵活
  - 每个主存块都映射到固定的缓存块，因此即使缓存 中还空闲很多空间也不能占用，**使缓存的存储空间得不到充分的利用**。
  - 例：如果程序恰好重复访问对应于同一缓存块的不 同主存块，例如，程序依次访问第 0、$2^c$ 、$2^{c+1}$ 、 $2^{c+2}$…个主存块，那么缓存每次都未命中，需要不 停地将主存块替换到第 0 个缓存块所在位置。

#### 全相联映射

- 某一主存块能映射到任一缓存块。
- <img src="_images/%E5%85%A8%E7%9B%B8%E8%BF%9E%E6%98%A0%E5%B0%84.png" alt="全相连映射" style="zoom:75%;" />
- 优点：全相联映射相比直接映射更加灵活，命中率更高。
- 缺点：**实现复杂，成本较高。**
  - 实现全相联映射的 Cache 需要大量逻辑电路，成本高。
  - 当 CPU 给出一个 n 位访存地址后，需要依次**比较所有缓存块**的 t+c 位**标记**与当前访存地址中的 t+c 位标记是否一致。在实际应用时，需要实现各种措施来尽可能减少标记比较次数，因此实现较为复杂。

#### 组相联映射

- 某一主存块只能映射某一缓存组中的任一块。
- <img src="_images/%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" alt="组相联映射" style="zoom:75%;" />
- 某一主存块 j 按模 Q 映射到缓存的第 i 组中的任一块。
  - 直接映射：某一主存块 j 按模 Q 映射到缓存的第 i 组；
  - 全相连映射：**任一块**。

#### PPT 上几个例题

上面图中关于主存子字块标记和主存地址的解释含混不清，看习题直接计算的话会好一点。

### 6.3.3 替换算法（仅了解）

#### 先进先出法（FIFO：First In First Out）

- 当 Cache 占满时，它总是选择最早调入 Cache 的字块进行替换。
- 优点：先进先出法容易实现、开销小，不需要记录 Cache 中各字块的使用情况。
- 缺陷：没有基于访存的局部性原理，不能提高 Cache 的命中率。

#### 近期最少使用法（LRU：Least Recently Used）

- 当 Cache 占满时，选择**近期用得最少**的字块进行替换。

- 近期最少使用法需要随时**记录** Cache 中各个缓存块的使用情况（记录从上一次使用到此刻的时间），并将间隔时间最长的缓存块替换掉，**实现较为复杂**。
- 近期最少使用法的平均命中率比先进先出法要高。

#### 最不经常使用法（LFU：Least Frequently Used）

- 最不经常使用法的思路与近期最少使用法类似，当 Cache 占满时，选择最**不经常使用**的字块进行替换。

- 最不经常使用法也需要随时记录 Cache 中各个缓存块的使用情况（**记录一定时间内每个缓存块被访问的次数**），并将访问次数最少的缓存块替换掉，**实现也较为复杂**。

- 最不经常使用法的平均命中率比先进先出法要高。

#### 随机替换法

- 当 Cache 占满时，随机选择一个缓存块替换。
- **实现简单**，但是也没有考虑程序访问的局部性原理，无法提高 Cache 的命中率。

## 6.4 虚拟存储器

虚拟存储器处于“主存-辅存”存储层次。

### 虚拟存储器思想的提出

- 主存容量限制带来的诸多不便
  - 用户编写程序必须考虑主存容量的限制
  - 多道程序设计的道数受到限制
- 用户编程行为分析
  - 全面考虑各种情况，执行时有互斥性
  - 顺序性和循环性等**空间局部性**行为
    - 空间局部性：一旦程序访问了某个存储单元，其附近的存储单元也将在不久之后被访问
  - 某一阶段执行的**时间局部性**行为
    - 时间局部性：某条指令一旦执行，不久的将来可能被再次执行
- **因此可以考虑只将进程涉及的部分内容调入内存**

### 虚拟存储器的基本思想

- 存储管理把进程全部信息放在辅存中，执行时先将其中一部分装入主存，以后根据执行行为**随用随调入**
- 如果主存中没有足够的空间，存储管理需要根据执行行为把主存中暂时不用的信息调出到辅存上去
- 虚拟存储采用与 Cache 类似原理，提高速度，降低成本
- 利用**程序局部性**，使存储系统的性能接近于高速存储器；价格接近于低速存储器，并扩充主存容量

### 虚拟存储器的实现思路

- 需要建立与自动管理两个地址空间
  - 辅存对应的虚拟地址空间，容纳进程装入
  - 主存对应的实际地址空间，承载进程执行
- 例子：32 位的计算机，内存大小为 1GB。对于程序员来说，可用地址空间为 $2^{32}$ 位 = 4GB，大于实际主存大小。实际上就采用了虚拟存储器技术：
  - 4GB 实际上使用的是辅存（磁盘）中的空间，仅使用 1GB 的内存就可实现 4GB 的地址空间
  - 进程在执行时首先都被装入辅存中，只将一部分代码和数据装入到 1GB 的内存中。后续根据进程的执行行为再陆续将需要执行的代码和数据调入到 1GB 的内存中。当内存被装满时，需要将不再使用的数据调出到辅存，为需要的数据腾出空间。
- 对于用户，计算机系统具有一个容量大得多的主存空间，即虚拟存储器，虚存空间是靠辅存（磁盘）来支持的。
- 虚拟存储器是一种**地址空间扩展技术**，通常意义上对用户编程是透明的，除非用户需要进行高性能的程序设计。
  - *透明：用户（包括程序员）不需要了解辅存与主存之间的数据调入和换出是如何实现。从用户角度来看，使用的就是 1 台内存地址空间大小为 4GB 的计算机。*

### 实地址计算机系统/虚地址计算机系统

略。

### 页式虚拟存储器

略。

### 页表结构

略。

### 虚实地址转换中存在的问题

略。

### TLB——快表提高页式管理速度

略。

### TLB虚实地址转换

略。

### TLB命中、缺失

略。

### 虚拟存储器与 Cache 的相似与差异

- 相似之处
  - 将程序中常用的部分驻留在高速存储器
    - 程序载入按需载入（不是全部载入）
    - 高速存储器分块或者分页（粒度问题）
    - 主存空间满，将不常用程序或数据**淘汰**或**交换**到辅存中
  - 数据的换入换出由硬件或操作系统完成，对用户透明
  - 利用程序局部性，使存储系统的性能接近于高速存储器；价格接近于低速存储器，并扩充主存容量
- 差异
  - 虚存用于扩大主存容量，Cache 用于加速主存性能
  - 虚存中未命中性能损失远大于 Cache 系统
    - 全相联提升命中率
    - 更大的交换单位页
    - 近似 LRU 算法 (CLOCK 算法)
  - 虚存由硬件和 OS 联合管理，Cache 由硬件管理

### 虚拟存储器小结

- 程序员在比实际主存大得多的逻辑地址空间中编程
- 程序执行时，按需载入代码和数据，无需全部载入
- 硬件将逻辑地址（虚拟地址）转化为物理地址（实地址）
- 缺页时，由**操作系统**进行主存和磁盘之间的信息交换
- 虚存机制由硬件与操作系统协作实现
  - 进程及进程上下文切换、存储器分配
  - 虚拟地址空间管理、缺页处理
  - 存储器保护

## 6.5 辅助存储器

### RAID

- 原名：Redundant Array of Inexpensive Disks，廉价磁盘冗余阵列
- 现名：Redundant Array of Independent Disks，独立磁盘冗余阵列
- 把多块独立的硬盘（物理硬盘）按不同的方式组合起来形成的一个硬盘组（逻辑硬盘），从而提供比单个硬盘**更高的存储性能**和**提供数据备份技术**

### RAID 的核心技术

- 将数据**条带化**后存放在不同磁盘上，通过多磁盘的**并行操作**提高磁盘系统的读写速率
- 使用基于**异或**运算为基础的校验技术**恢复损坏的数据**

### 常见的几种 RAID 技术

- RAID 0：数据以条带方式均匀分散在各磁盘。无冗余

- RAID 1：镜像磁盘阵列。数据采用镜像的冗余方式，同一数据有多份拷贝

- RAID 2：纠错海明码磁盘阵列。

- RAID 3/4：奇校验或偶校验的磁盘阵列。 数据按**位/条带**并行传输到多个磁盘上，同时奇偶校验数据存放到专用校验盘上。

- RAID 5：奇校验或偶校验的磁盘阵列。数据按条带分布在不同磁盘上，校验信息被均匀分散到各磁盘上

- RAID 1 0：结合 RAID 1 和 RAID 0。先镜像，再条带化

- RAID 0 1：结合 RAID 0 和 RAID 1。先条带化，再镜像

### RAID 的实现方式

- 软件 RAID
  - 依赖于主机 CPU 完成，没有第三方的控制处理器和 I/O 芯片

- 硬件 RAID
  - 专用 RAID 控制处理器和 I/O 芯片处理 RAID 任务，不占 CPU

### RAID 小结

|  RAID 级别   |    RAID 0    |     RAID 1     |        RAID 3        |        RAID 5        |     RAID 1 0      |
| :----------: | :----------: | :------------: | :------------------: | :------------------: | :---------------: |
|    容错性    |      无      |       有       |          有          |          有          |        有         |
|   冗余类型   |      无      |      镜像      |       奇偶校验       |       奇偶校验       |       镜像        |
|     备盘     |      无      |       有       |          有          |          有          |        有         |
|    读性能    |      高      |       低       |          高          |          高          |       中间        |
|  随机写性能  |      高      |       低       |         最低         |          低          |       中间        |
|  连续写性能  |      高      |       低       |          低          |          低          |       中间        |
| 需要的磁盘数 |  2 个或更多  |  2 个或 2N 个  |      3 个或更多      |      3 个或更多      | 4 个或 2N (N > 2) |
|   可用容量   | 总的磁盘容量 | 磁盘容量的 50% | 磁盘容量的 (N-1) / N | 磁盘容量的 (N-1) / N |  磁盘容量的 50%   |

